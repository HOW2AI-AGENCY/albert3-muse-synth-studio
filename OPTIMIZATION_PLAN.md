# OPTIMIZATION_PLAN.md - План оптимизации и рефакторинга

**Дата:** 27.11.2025
**Аудитор:** Jules, Senior AI Engineering Auditor & Optimizer

## 1. Общая стратегия

Рефакторинг будет проводиться поэтапно, с фокусом на минимизацию рисков. Мы начнем с наиболее изолированного и наименее связанного с UI "божественного объекта" (`suno.ts`) на бэкенде, а затем перейдем к ядру фронтенда, постепенно рефакторя state-менеджер и UI-компоненты.

**Главный принцип:** Один коммит — один успешный шаг рефакторинга. После каждого шага приложение должно оставаться в полностью рабочем состоянии.

---

## 2. Порядок задач и план рефакторинга

### Задача 1: Рефакторинг API-клиента для Suno

*   **Проблема (P0):** Монолитный файл `supabase/functions/_shared/suno.ts` (1133 строки) содержит всю логику, типы и утилиты для работы с Suno API.
*   **Предлагаемое решение:** Разбить файл на несколько модулей, следующих принципу единственной ответственности.
*   **План рефакторинга:**
    1.  Создать `supabase/functions/_shared/suno.types.ts` и перенести в него все интерфейсы (`SunoGenerationPayload`, `SunoTrack`, и т.д.).
    2.  Создать `supabase/functions/_shared/suno.utils.ts` и перенести туда вспомогательные функции (`parseTaskId`, `buildSunoHeaders`, и т.д.).
    3.  Создать базовый API-клиент `supabase/functions/_shared/suno.client.ts`, который будет инкапсулировать логику `fetch`, обработку ошибок, ретраи и circuit breaker.
    4.  Разделить основную логику `suno.ts` на функциональные модули (например, `suno.generation.ts`, `suno.lyrics.ts`), которые будут использовать базовый клиент.
    5.  Обновить `createSunoClient` для сборки итогового клиента из этих модулей.
    6.  Аккуратно обновить все импорты в других Supabase функциях, которые используют `suno.ts`.
*   **Риски:** **Средние.** Изменения затрагивают критически важную часть бэкенда. Ошибка может привести к отказу всей функциональности генерации музыки.
*   **План отката:** `git restore supabase/functions/_shared/`. Так как это бэкенд-изменения, откат не затронет развернутый фронтенд.
*   **Оценка усилий:** **Средняя.**
*   **Влияние на производительность:** Непрямое. Улучшит стабильность за счет более чистого кода, но не изменит скорость ответа API.
*   **Зависимости:** **Нет.** Эта задача является идеальной отправной точкой.

---

### Задача 2: Рефакторинг state-менеджера плеера

*   **Проблема (P0, P1):** "God Store" `src/stores/audioPlayerStore.ts` (874 строки) смешивает управление UI-состоянием с логикой запросов к API.
*   **Предлагаемое решение:** Разделить стор на логические "слайсы" и вынести логику загрузки данных в специализированный хук на базе TanStack Query.
*   **План рефакторинга:**
    1.  Создать хук `useTrackVersions` с использованием `@tanstack/react-query` для замены внутренней функции `_fetchVersionsFromApi`. Это позволит кешировать и автоматически обновлять версии треков.
    2.  Разделить состояние и действия в `audioPlayerStore.ts` на слайсы: `playbackSlice`, `queueSlice`, `versionSlice`.
    3.  Объединить слайсы в единый стор, как это позволяет делать Zustand.
    4.  Провести рефакторинг UI-компонентов, использующих стор, чтобы они обращались к новым, более гранулярным селекторам и действиям.
*   **Риски:** **Высокие.** Плеер — глобальный и критически важный элемент UI. Любая ошибка будет немедленно замечена пользователем и может полностью сломать основной функционал приложения.
*   **План отката:** `git restore src/stores/audioPlayerStore.ts` и связанные компоненты.
*   **Оценка усилий:** **Высокая.**
*   **Влияние на производительность:** **Положительное.** Уменьшится количество ненужных ререндеров. Улучшится UX за счет кеширования данных о версиях треков.
*   **Зависимости:** Рекомендуется выполнять после Задачи 1.

---

### Задача 3: Декомпозиция компонента генератора музыки

*   **Проблема (P0, P2):** "God Component" `src/components/generator/MusicGeneratorContainer.tsx` (768 строк) с огромным количеством логики и пропсов.
*   **Предлагаемое решение:** Разбить компонент на более мелкие, сфокусированные хуки и компоненты, используя React Context для устранения "prop drilling".
*   **План рефакторинга:**
    1.  Создать `GeneratorContext` для предоставления состояния из хука `useGeneratorState` всем дочерним компонентам.
    2.  Вынести сложную логику в кастомные хуки:
        *   `usePromptEnhancer` (для логики `handleBoostPrompt`).
        *   `useGenerationHandler` (для основной логики `handleGenerate`).
        *   `useRemixLoader` (для `useEffect` с `localStorage`).
    3.  Разбить `MusicGeneratorContent` на более мелкие компоненты (`GeneratorForm`, `GeneratorAdvancedOptions`, `GeneratorReferenceAudio`).
    4.  Основной компонент-контейнер останется для оркестрации хуков и провайдера контекста.
*   **Риски:** **Средние.** Затрагивается основная функция приложения — генерация музыки.
*   **План отката:** `git restore src/components/generator/`.
*   **Оценка усилий:** **Высокая.**
*   **Влияние на производительность:** **Положительное.** Улучшится отзывчивость интерфейса за счет более гранулярного состояния и уменьшения ререндеров.
*   **Зависимости:** Нет.

---

### Задача 4: Декомпозиция страницы библиотеки

*   **Проблема (P0):** "God Component" `src/pages/workspace/Library.tsx` (848 строк).
*   **Предлагаемое решение:** Разбить страницу на иерархию более мелких, логически связанных компонентов.
*   **План рефакторинга:**
    1.  Создать компонент `LibraryHeader.tsx` (заголовок, счетчик, переключатели вида).
    2.  Создать компонент `LibraryFilters.tsx` (поиск, фильтры, сортировка) и переместить туда хук `useLibraryFilters`.
    3.  Создать хук `useTrackActions`, который инкапсулирует всю логику действий над треками (`handleDelete`, `handleShare` и т.д.).
    4.  Основной компонент `Library.tsx` будет отвечать за загрузку данных и композицию новых компонентов.
*   **Риски:** **Средние.** Библиотека — одна из самых посещаемых страниц.
*   **План отката:** `git restore src/pages/workspace/Library.tsx`.
*   **Оценка усилий:** **Средняя.**
*   **Влияние на производительность:** Незначительное, но код станет значительно чище.
*   **Зависимости:** Нет.
