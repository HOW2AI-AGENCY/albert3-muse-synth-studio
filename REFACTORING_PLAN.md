# План Рефакторинга Prompt DJ: От React к LitElement

## 1. Целевая Архитектура

Цель — перевести приложение Prompt DJ на событийно-ориентированную архитектуру с использованием `LitElement` для UI-компонентов. Это повысит производительность, модульность и упростит поддержку.

- **`PromptDjMidi.ts` ("Мозг"):** Центральный класс для управления состоянием (промпты, веса, MIDI-мэппинг).
- **`LiveMusicHelper.ts` ("Сердце"):** Инкапсуляция всей логики взаимодействия с Gemini Lyria API.
- **UI Components (`LitElement`):** Независимые, переиспользуемые веб-компоненты.
- **Система событий ("Нервная система"):** Асинхронное взаимодействие через `Custom Events`.

## 2. Текущее Состояние

- **Фреймворк:** React с использованием `useState` и `useCallback`.
- **Компоненты:** Структура разбита на компоненты (`PromptDJHeader`, `PromptGrid` и т.д.), но они тесно связаны через пропсы.
- **Функционал:** Реализованы пресеты (локально), запись в WAV (через `AudioWorklet`) и анализатор спектра. MIDI-управление и референсное аудио отсутствуют.

## 3. Этапы Миграции

### Этап 1: Интеграция Web MIDI API

**Задача:** Реализовать полное управление контроллерами через MIDI-устройства.

1.  **Создать `MidiDispatcher.ts`:**
    - Реализовать класс для работы с `Web MIDI API`.
    - Добавить методы для поиска устройств и прослушивания `cc-message`.
    - Диспетчеризация `CustomEvent` при получении MIDI-сообщений.
2.  **Интегрировать в `PromptDJ.tsx`:**
    - Создать экземпляр `MidiDispatcher`.
    - Подписать основной компонент на события от MIDI-диспетчера.
3.  **Реализовать режим "Learn":**
    - Добавить в `PromptController` кнопку "Learn" (`CC:X`).
    - Реализовать логику ожидания следующего `cc-message` и сохранения его номера.
    - Сохранять MIDI-мэппинг в `localStorage`.

### Этап 2: Покомпонентная Миграция на LitElement

**Задача:** Постепенно заменить React-компоненты на `LitElement`.

1.  **`PromptController` -> `<prompt-controller>`:**
    - Создать `LitElement`-версию контроллера с вертикальным слайдером.
    - Перенести логику отслеживания движений мыши и рендеринга.
    - Компонент должен генерировать событие `weight-changed`.
2.  **`PromptGrid` -> `<prompt-grid>`:**
    - Создать `LitElement`, который будет содержать 16 экземпляров `<prompt-controller>`.
    - Прослушивать события `weight-changed` и "пробрасывать" их наверх.
3.  **Остальные компоненты:** По аналогии перевести `PromptDJHeader`, `PromptDJToolbar` и другие.

### Этап 3: Централизация Состояния в `PromptDjMidi.ts`

**Задача:** Убрать логику управления состоянием из React и перенести ее в "мозг" приложения.

1.  **Создать `PromptDjMidi.ts`:**
    - Перенести состояние (`prompts`, `playbackState` и т.д.) из `PromptDJ.tsx`.
    - Реализовать публичные методы для изменения состояния (`updateWeight`, `setPromptText`).
    - `PromptDjMidi` должен слушать события от UI-компонентов и вызывать методы `LiveMusicHelper`.
2.  **Рефакторинг `PromptDJ.tsx`:**
    - Удалить `useState` и связанные с ним хуки.
    - `PromptDJ.tsx` (или его аналог на Lit) будет только инициализировать `PromptDjMidi` и `LiveMusicHelper` и связывать их.

### Этап 4: Реализация "Reference Audio"

**Задача:** Добавить возможность использовать записанный звук как источник "вдохновения" для нейросети.

1.  **Доработать `LiveMusicHelper.ts`:**
    - Добавить метод `setReferenceAudio(blob: Blob)`.
    - Этот метод должен отправлять аудиоданные на сервер через WebSocket или отдельный HTTP-запрос, в зависимости от спецификации Lyria API.
2.  **Обновить UI:**
    - Привязать к кнопке "Использовать как референс" вызов `LiveMusicHelper.setReferenceAudio`.
    - Добавить визуальную индикацию, что референсное аудио активно.

### Этап 5: Динамический Фон

**Задача:** Реализовать "живой" фон, который меняется в зависимости от микса.

1.  **Создать компонент `<dynamic-background>`:**
    - `LitElement`, который содержит набор CSS-градиентов.
2.  **Интеграция с `PromptDjMidi.ts`:**
    - Компонент подписывается на событие изменения весов от "мозга".
    - При изменении веса промпта, компонент обновляет `opacity` и `transform` соответствующего градиента.

## 4. Оценка Рисков

- **Сложность интеграции Lit и React:** На этапе миграции (Этап 2) потребуется настроить совместную работу двух фреймворков. Это может потребовать дополнительных исследований.
- **Асинхронность:** Событийная модель требует внимательного управления асинхронными операциями, чтобы избежать гонок состояний.
- **Производительность `AudioWorklet`:** Необходимо тщательно протестировать производительность ворлета при длительной записи.
