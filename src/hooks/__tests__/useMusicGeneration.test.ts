import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { act, waitFor } from '@testing-library/react';
import { useMusicGenerationStore } from '@/stores/useMusicGenerationStore';
import { ApiService } from '@/services/api.service';
import { supabase } from '@/integrations/supabase/client';
import type { RealtimeChannel } from '@supabase/supabase-js';

// ========== MOCKS ==========

vi.mock('@/services/api.service', () => ({
  ApiService: {
    createTrack: vi.fn(),
    generateMusic: vi.fn(),
    improvePrompt: vi.fn(),
  },
}));

const mockChannel = {
  on: vi.fn().mockReturnThis(),
  subscribe: vi.fn().mockReturnThis(),
  unsubscribe: vi.fn(),
} as unknown as RealtimeChannel;

vi.mock('@/integrations/supabase/client', () => ({
  supabase: {
    auth: {
      getUser: vi.fn(),
    },
    channel: vi.fn(() => mockChannel),
    functions: {
      invoke: vi.fn(),
    },
  },
}));

vi.mock('@/utils/logger', () => ({
  logError: vi.fn(),
  logInfo: vi.fn(),
  logger: {
    warn: vi.fn(),
  },
}));

// ========== TESTS ==========

describe('useMusicGenerationStore', () => {
  const mockUser = { id: 'user-123', email: 'test@example.com' };
  const mockToast = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(supabase.auth.getUser).mockResolvedValue({
      data: { user: mockUser as any },
      error: null,
    });
    vi.mocked(ApiService.createTrack).mockResolvedValue({
      id: 'track-123',
      title: 'Test Track',
      status: 'pending',
    } as any);
    vi.mocked(ApiService.generateMusic).mockResolvedValue({
      success: true,
      trackId: 'track-123',
    } as any);
    vi.mocked(supabase.functions.invoke).mockResolvedValue({
      data: { success: true },
      error: null,
    });
  });

  afterEach(() => {
    // Cleanup store state
    useMusicGenerationStore.getState().cleanupSubscription();
  });

  describe('setProvider', () => {
    it('–¥–æ–ª–∂–µ–Ω –∏–∑–º–µ–Ω—è—Ç—å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞', () => {
      const { setProvider } = useMusicGenerationStore.getState();
      
      act(() => {
        setProvider('mureka');
      });

      expect(useMusicGenerationStore.getState().selectedProvider).toBe('mureka');
    });
  });

  describe('improvePrompt', () => {
    it('–¥–æ–ª–∂–µ–Ω —É–ª—É—á—à–∞—Ç—å –ø—Ä–æ–º–ø—Ç —á–µ—Ä–µ–∑ API', async () => {
      const improvedText = '–£–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç —Å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–µ–π';
      vi.mocked(ApiService.improvePrompt).mockResolvedValue({
        improvedPrompt: improvedText,
      } as any);

      const { improvePrompt } = useMusicGenerationStore.getState();
      
      let result: string | null = null;
      await act(async () => {
        result = await improvePrompt('–ø—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–º–ø—Ç', mockToast);
      });

      expect(result).toBe(improvedText);
      expect(mockToast).toHaveBeenCalledWith({
        title: '‚ú® –ü—Ä–æ–º–ø—Ç —É–ª—É—á—à–µ–Ω!',
        description: '–í–∞—à–µ –æ–ø–∏—Å–∞–Ω–∏–µ –±—ã–ª–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ —Å –ø–æ–º–æ—â—å—é AI.',
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –ø—Ä–∏ —É–ª—É—á—à–µ–Ω–∏–∏', async () => {
      const error = new Error('API Error');
      vi.mocked(ApiService.improvePrompt).mockRejectedValue(error);

      const { improvePrompt } = useMusicGenerationStore.getState();
      
      let result: string | null = null;
      await act(async () => {
        result = await improvePrompt('–ø—Ä–æ–º–ø—Ç', mockToast);
      });

      expect(result).toBeNull();
      expect(mockToast).toHaveBeenCalledWith({
        title: '–û—à–∏–±–∫–∞',
        description: 'API Error',
        variant: 'destructive',
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –ø—É—Å—Ç–æ–π –ø—Ä–æ–º–ø—Ç', async () => {
      const { improvePrompt } = useMusicGenerationStore.getState();
      
      let result: string | null = null;
      await act(async () => {
        result = await improvePrompt('', mockToast);
      });

      expect(result).toBeNull();
      expect(mockToast).toHaveBeenCalledWith({
        title: '–û—à–∏–±–∫–∞',
        description: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º—É–∑—ã–∫–∏ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è.',
        variant: 'destructive',
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ –≤—ã–∑–æ–≤—ã –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è', async () => {
      vi.mocked(ApiService.improvePrompt).mockImplementation(
        () => new Promise(resolve => setTimeout(() => resolve({ improvedPrompt: 'test' } as any), 100))
      );

      const { improvePrompt } = useMusicGenerationStore.getState();
      
      await act(async () => {
        const promise1 = improvePrompt('–ø—Ä–æ–º–ø—Ç', mockToast);
        const promise2 = improvePrompt('–ø—Ä–æ–º–ø—Ç', mockToast);
        
        await promise1;
        const result2 = await promise2;
        
        expect(result2).toBeNull();
      });
    });
  });

  describe('generateMusic', () => {
    it('–¥–æ–ª–∂–µ–Ω –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –º—É–∑—ã–∫—É —Å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º suno', async () => {
      const { generateMusic } = useMusicGenerationStore.getState();
      const onSuccess = vi.fn();

      let result: boolean = false;
      await act(async () => {
        result = await generateMusic({
          prompt: '—ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è —Ä–æ–∫ –º—É–∑—ã–∫–∞',
          title: '–†–æ–∫ —Ç—Ä–µ–∫',
          provider: 'suno',
        }, mockToast, onSuccess);
      });

      expect(result).toBe(true);
      expect(ApiService.createTrack).toHaveBeenCalledWith(
        mockUser.id,
        '–†–æ–∫ —Ç—Ä–µ–∫',
        '—ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è —Ä–æ–∫ –º—É–∑—ã–∫–∞',
        'suno',
        undefined,
        undefined,
        undefined
      );
      expect(ApiService.generateMusic).toHaveBeenCalled();
      expect(mockToast).toHaveBeenCalledWith({
        title: 'üéµ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª–∞—Å—å!',
        description: '–í–∞—à —Ç—Ä–µ–∫ —Å–æ–∑–¥–∞—ë—Ç—Å—è. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –æ–∫–æ–ª–æ –º–∏–Ω—É—Ç—ã...',
      });
      expect(onSuccess).toHaveBeenCalled();
    });

    it('–¥–æ–ª–∂–µ–Ω –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –º—É–∑—ã–∫—É —Å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º mureka', async () => {
      const { generateMusic } = useMusicGenerationStore.getState();

      let result: boolean = false;
      await act(async () => {
        result = await generateMusic({
          prompt: '—Å–ø–æ–∫–æ–π–Ω–∞—è —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –º—É–∑—ã–∫–∞',
          title: 'Ambient Track',
          provider: 'mureka',
        }, mockToast);
      });

      expect(result).toBe(true);
      expect(supabase.functions.invoke).toHaveBeenCalledWith('generate-mureka', {
        body: expect.objectContaining({
          trackId: 'track-123',
          title: 'Ambient Track',
          prompt: '—Å–ø–æ–∫–æ–π–Ω–∞—è —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –º—É–∑—ã–∫–∞',
        })
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –ø—É—Å—Ç–æ–π –ø—Ä–æ–º–ø—Ç', async () => {
      const { generateMusic } = useMusicGenerationStore.getState();

      let result: boolean = false;
      await act(async () => {
        result = await generateMusic({
          prompt: '   ',
          title: 'Test',
        }, mockToast);
      });

      expect(result).toBe(false);
      expect(mockToast).toHaveBeenCalledWith({
        title: '–û—à–∏–±–∫–∞',
        description: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º—É–∑—ã–∫–∏',
        variant: 'destructive',
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é', async () => {
      vi.mocked(supabase.auth.getUser).mockResolvedValue({
        data: { user: null },
        error: null,
      } as any);

      const { generateMusic } = useMusicGenerationStore.getState();

      let result: boolean = false;
      await act(async () => {
        result = await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      expect(result).toBe(false);
      expect(mockToast).toHaveBeenCalledWith({
        title: '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è',
        description: '–í–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º—É–∑—ã–∫–∏',
        variant: 'destructive',
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—Ç—å –¥–≤–æ–π–Ω—ã–µ –∫–ª–∏–∫–∏ (debounce)', async () => {
      const { generateMusic } = useMusicGenerationStore.getState();

      await act(async () => {
        const result1 = await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
        
        // Immediate second call should be ignored
        const result2 = await generateMusic({
          prompt: '—Ç–µ—Å—Ç 2',
          title: 'Test 2',
        }, mockToast);

        expect(result1).toBe(true);
        expect(result2).toBe(false);
        expect(ApiService.createTrack).toHaveBeenCalledTimes(1);
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –ø–æ–¥–ø–∏—Å—ã–≤–∞—Ç—å—Å—è –Ω–∞ realtime –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è', async () => {
      const { generateMusic } = useMusicGenerationStore.getState();

      await act(async () => {
        await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      expect(supabase.channel).toHaveBeenCalledWith('track-status:track-123');
      expect(mockChannel.on).toHaveBeenCalled();
      expect(mockChannel.subscribe).toHaveBeenCalled();
    });

    it('–¥–æ–ª–∂–µ–Ω –æ—á–∏—â–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏', async () => {
      const mockOnCallback = vi.fn();
      vi.mocked(mockChannel.on).mockImplementation((_event, _filter, callback: any) => {
        mockOnCallback.mockImplementation(callback);
        return mockChannel;
      });

      const { generateMusic } = useMusicGenerationStore.getState();

      await act(async () => {
        await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      // Simulate realtime update with status 'completed'
      await act(async () => {
        mockOnCallback({
          new: {
            status: 'completed',
            title: 'Test',
          },
        });
      });

      await waitFor(() => {
        expect(mockToast).toHaveBeenCalledWith({
          title: '‚úÖ –¢—Ä–µ–∫ –≥–æ—Ç–æ–≤!',
          description: '–í–∞—à —Ç—Ä–µ–∫ "Test" —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω.',
        });
        expect(mockChannel.unsubscribe).toHaveBeenCalled();
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å failed —Å—Ç–∞—Ç—É—Å', async () => {
      const mockOnCallback = vi.fn();
      vi.mocked(mockChannel.on).mockImplementation((_event, _filter, callback: any) => {
        mockOnCallback.mockImplementation(callback);
        return mockChannel;
      });

      const { generateMusic } = useMusicGenerationStore.getState();

      await act(async () => {
        await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      // Simulate realtime update with status 'failed'
      await act(async () => {
        mockOnCallback({
          new: {
            status: 'failed',
            title: 'Test',
            error_message: 'Generation timeout',
          },
        });
      });

      await waitFor(() => {
        expect(mockToast).toHaveBeenCalledWith({
          title: '‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏',
          description: 'Generation timeout',
          variant: 'destructive',
        });
        expect(mockChannel.unsubscribe).toHaveBeenCalled();
      });
    });

    it('–¥–æ–ª–∂–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç', async () => {
      vi.useFakeTimers();

      const { generateMusic } = useMusicGenerationStore.getState();

      await act(async () => {
        await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      // Fast-forward 5 minutes
      await act(async () => {
        vi.advanceTimersByTime(5 * 60 * 1000);
      });

      await waitFor(() => {
        expect(mockChannel.unsubscribe).toHaveBeenCalled();
      });

      vi.useRealTimers();
    });

    it('–¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏', async () => {
      const networkError = new Error('Failed to fetch');
      vi.mocked(ApiService.createTrack).mockRejectedValue(networkError);

      const { generateMusic } = useMusicGenerationStore.getState();

      let result: boolean = false;
      await act(async () => {
        result = await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      expect(result).toBe(false);
      expect(mockToast).toHaveBeenCalledWith({
        title: '–ü—Ä–æ–±–ª–µ–º–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è',
        description: expect.stringContaining('–ù–µ—Ç —Å–≤—è–∑–∏ —Å Supabase'),
        variant: 'destructive',
      });
    });
  });

  describe('cleanupSubscription', () => {
    it('–¥–æ–ª–∂–µ–Ω –æ—á–∏—â–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –∏ —Ç–∞–π–º–µ—Ä', async () => {
      vi.useFakeTimers();
      
      const { generateMusic, cleanupSubscription } = useMusicGenerationStore.getState();

      await act(async () => {
        await generateMusic({
          prompt: '—Ç–µ—Å—Ç',
          title: 'Test',
        }, mockToast);
      });

      expect(useMusicGenerationStore.getState().subscription).toBeTruthy();
      expect(useMusicGenerationStore.getState().autoCleanupTimer).toBeTruthy();

      act(() => {
        cleanupSubscription();
      });

      expect(useMusicGenerationStore.getState().subscription).toBeNull();
      expect(useMusicGenerationStore.getState().autoCleanupTimer).toBeNull();
      expect(mockChannel.unsubscribe).toHaveBeenCalled();

      vi.useRealTimers();
    });
  });
});
