/**
 * Extend Track Handler - Phase 2 Implementation
 * Unified handler for track extension (both extend-track and upload-extend-audio)
 */

import { BaseSunoHandler, type TrackCreationResult } from "./BaseSunoHandler.ts";
import { logger } from "../logger.ts";

export interface ExtendTrackParams {
  trackId: string;
  uploadUrl?: string;
  continueAt?: number;
  prompt?: string;
  tags?: string[];
  title?: string;
  model?: string;
  defaultParamFlag?: boolean;
  instrumental?: boolean;
  personaId?: string;
  negativeTags?: string;
  vocalGender?: 'm' | 'f';
  styleWeight?: number;
  weirdnessConstraint?: number;
  audioWeight?: number;
}

export interface ExtendTrackResult {
  success: boolean;
  trackId: string;
  taskId: string;
}

export class ExtendTrackHandler extends BaseSunoHandler {
  /**
   * ✅ Get original track with validation
   */
  private async getOriginalTrack(trackId: string): Promise<any> {
    const { data: track, error } = await this.supabase
      .from('tracks')
      .select('*')
      .eq('id', trackId)
      .eq('user_id', this.userId)
      .single();

    if (error || !track) {
      logger.error('Original track not found', { error: error ? new Error(error.message) : new Error('Track not found'), trackId, userId: this.userId });
      throw new Error('Track not found or access denied');
    }

    if (!track.audio_url && !track.suno_id) {
      throw new Error('Track has no audio to extend');
    }

    if (!track.suno_id) {
      throw new Error('Track was not generated by Suno and cannot be extended');
    }

    return track;
  }

  /**
   * ✅ Execute track extension
   */
  async execute(params: ExtendTrackParams): Promise<ExtendTrackResult> {
    logger.info('ExtendTrackHandler: Starting execution', {
      trackId: params.trackId,
      hasUploadUrl: !!params.uploadUrl,
      userId: this.userId,
    });

    // 1. Validate original track
    const originalTrack = await this.getOriginalTrack(params.trackId);

    // 2. Extract model
    const model = params.model ||
      originalTrack.metadata?.model ||
      originalTrack.model_name ||
      'V4';

    // 3. Create extension track record
    const { trackId: newTrackId } = await this.createTrackRecord({
      userId: this.userId,
      title: params.title || `${originalTrack.title} (Extended)`,
      prompt: params.prompt || originalTrack.prompt || '',
      tags: params.tags || originalTrack.style_tags,
      lyrics: originalTrack.lyrics,
      make_instrumental: params.instrumental,
      model_version: model,
      metadata: {
        extended_from: params.trackId,
        continue_at: params.continueAt,
        original_duration: originalTrack.duration_seconds || originalTrack.duration,
        model,
      },
    });

    // 4. Build Suno API payload
    const useCustomParams = params.defaultParamFlag ?? (!!params.prompt || !!params.tags || !!params.title);

    // Determine endpoint based on whether we have uploadUrl
    const endpoint = params.uploadUrl
      ? 'https://api.sunoapi.org/api/v1/generate/upload-extend'
      : 'https://api.sunoapi.org/api/v1/generate/extend';

    const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
    const callbackUrl = `${SUPABASE_URL}/functions/v1/suno-callback`;

    const sunoPayload: Record<string, unknown> = {
      audioId: originalTrack.suno_id,
      defaultParamFlag: useCustomParams,
      model,
      callBackUrl: callbackUrl,
    };

    // Add uploadUrl if provided
    if (params.uploadUrl) {
      sunoPayload.uploadUrl = params.uploadUrl;
    }

    // Add continueAt
    if (params.continueAt !== undefined) {
      sunoPayload.continueAt = params.continueAt;
    } else if (originalTrack.duration_seconds) {
      sunoPayload.continueAt = Math.max(0, originalTrack.duration_seconds - 20);
    } else if (originalTrack.duration) {
      sunoPayload.continueAt = Math.max(0, originalTrack.duration - 20);
    }

    // Add custom parameters
    if (useCustomParams) {
      if (params.prompt || originalTrack.prompt) {
        sunoPayload.prompt = params.prompt || originalTrack.prompt;
      }
      if (params.tags && params.tags.length > 0) {
        sunoPayload.style = params.tags.join(', ');
      } else if (originalTrack.style_tags && originalTrack.style_tags.length > 0) {
        sunoPayload.style = originalTrack.style_tags.join(', ');
      }
      if (params.title) {
        sunoPayload.title = params.title;
      } else {
        sunoPayload.title = `${originalTrack.title} (Extended)`;
      }
    }

    // Add advanced parameters
    if (params.instrumental !== undefined) {
      sunoPayload.instrumental = params.instrumental;
    }
    if (params.personaId) {
      sunoPayload.personaId = params.personaId;
    }
    if (params.negativeTags) {
      sunoPayload.negativeTags = params.negativeTags;
    }
    if (params.vocalGender) {
      sunoPayload.vocalGender = params.vocalGender;
    }
    if (params.styleWeight !== undefined) {
      sunoPayload.styleWeight = params.styleWeight;
    }
    if (params.weirdnessConstraint !== undefined) {
      sunoPayload.weirdnessConstraint = params.weirdnessConstraint;
    }
    if (params.audioWeight !== undefined) {
      sunoPayload.audioWeight = params.audioWeight;
    }

    // 5. Call Suno API
    try {
      const result = await this.callSunoAPI(endpoint, sunoPayload);
      const taskId = this.extractTaskId(result);

      // 6. Update track with task ID
      await this.updateTrackStatus(newTrackId, 'processing', {
        suno_task_id: taskId,
      });

      logger.info('ExtendTrackHandler: Execution successful', {
        originalTrackId: params.trackId,
        newTrackId,
        taskId,
      });

      return {
        success: true,
        trackId: newTrackId,
        taskId,
      };
    } catch (error) {
      // Update track status to failed
      await this.updateTrackStatus(newTrackId, 'failed', {
        error_message: (error as Error).message,
      });

      throw error;
    }
  }
}
