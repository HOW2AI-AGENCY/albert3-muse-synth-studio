import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createCorsHeaders } from "../_shared/cors.ts";
import { createSecurityHeaders } from "../_shared/security.ts";
import { createSupabaseAdminClient, createSupabaseUserClient } from "../_shared/supabase.ts";
import { logger } from "../_shared/logger.ts";

interface ExtendTrackRequest {
  trackId: string;
  continueAt?: number; // seconds from start to continue from
  prompt?: string; // optional new prompt for extension
  tags?: string[];
  model?: "V3_5" | "V4" | "V4_5" | "V4_5PLUS" | "V5";
  defaultParamFlag?: boolean;
}

const corsHeaders = createCorsHeaders();
const securityHeaders = createSecurityHeaders();

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: { ...corsHeaders, ...securityHeaders } });
  }

  try {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞ Authorization
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      logger.error('‚ùå [EXTEND] No Authorization header');
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const token = authHeader.replace('Bearer ', '');
    const supabaseUser = createSupabaseUserClient(token);
    const { data: { user }, error: authError } = await supabaseUser.auth.getUser();
    
    if (authError || !user) {
      logger.error('‚ùå [EXTEND] Unauthorized', { authError });
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const body: ExtendTrackRequest = await req.json();
    const { trackId, continueAt, prompt, tags, model, defaultParamFlag } = body;

    if (!trackId) {
      return new Response(
        JSON.stringify({ error: 'trackId is required' }),
        { status: 400, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    logger.info('üéµ [EXTEND] Starting track extension', { trackId, userId: user.id, continueAt });

    const supabaseAdmin = createSupabaseAdminClient();

    // –ü–æ–ª—É—á–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫
    const { data: originalTrack, error: trackError } = await supabaseAdmin
      .from('tracks')
      .select('*')
      .eq('id', trackId)
      .eq('user_id', user.id)
      .single();

    if (trackError || !originalTrack) {
      logger.error('‚ùå [EXTEND] Track not found', { trackId, error: trackError });
      return new Response(
        JSON.stringify({ error: 'Track not found or access denied' }),
        { status: 404, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!originalTrack.audio_url) {
      logger.error('‚ùå [EXTEND] Track has no audio', { trackId });
      return new Response(
        JSON.stringify({ error: 'Track has no audio to extend' }),
        { status: 400, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Validate that track has suno_id (required for Suno API)
    if (!originalTrack.suno_id) {
      logger.error('‚ùå [EXTEND] Track has no suno_id', { trackId });
      return new Response(
        JSON.stringify({ error: 'Track was not generated by Suno and cannot be extended' }),
        { status: 400, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Extract model from original track
    const extractedModel = model || 
      originalTrack.metadata?.model || 
      originalTrack.model_name || 
      'V4'; // fallback to V4

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ç—Ä–µ–∫ –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    const { data: newTrack, error: createError } = await supabaseAdmin
      .from('tracks')
      .insert({
        user_id: user.id,
        title: `${originalTrack.title} (Extended)`,
        prompt: prompt || originalTrack.prompt,
        status: 'processing',
        provider: 'suno',
        style_tags: tags || originalTrack.style_tags,
        model_name: extractedModel,
        metadata: {
          extended_from: trackId,
          continue_at: continueAt,
          original_duration: originalTrack.duration,
          model: extractedModel
        }
      })
      .select()
      .single();

    if (createError || !newTrack) {
      logger.error('‚ùå [EXTEND] Failed to create extended track', { error: createError });
      throw new Error('Failed to create extended track');
    }

    logger.info('‚úÖ [EXTEND] Created extended track record', { 
      newTrackId: newTrack.id, 
      originalTrackId: trackId 
    });

    // –í—ã–∑—ã–≤–∞–µ–º Suno API –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è —Ç—Ä–µ–∫–∞
    const SUNO_API_KEY = Deno.env.get('SUNO_API_KEY');
    if (!SUNO_API_KEY) {
      throw new Error('SUNO_API_KEY not configured');
    }

    const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
    const callbackUrl = `${SUPABASE_URL}/functions/v1/suno-callback`;

    // Determine if we use custom params or original track params
    const useCustomParams = defaultParamFlag ?? (!!prompt || !!tags);

    const sunoPayload: any = {
      defaultParamFlag: useCustomParams,
      audioId: originalTrack.suno_id,
      model: extractedModel,
      callBackUrl: callbackUrl
    };

    if (useCustomParams) {
      sunoPayload.prompt = prompt || originalTrack.prompt;
      sunoPayload.tags = tags || originalTrack.style_tags || []; // ‚úÖ tags –º–∞—Å—Å–∏–≤
      sunoPayload.title = `${originalTrack.title} (Extended)`;
      sunoPayload.continueAt = continueAt || Math.max(0, (originalTrack.duration || 120) - 20);
      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º referenceAudioUrl –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
      if (originalTrack.reference_audio_url) {
        sunoPayload.referenceAudioUrl = originalTrack.reference_audio_url;
      }
    }

    logger.info('üì§ [EXTEND] Payload details', {
      hasReferenceAudio: !!sunoPayload.referenceAudioUrl,
      payloadKeys: Object.keys(sunoPayload)
    });

    logger.info('üì§ [EXTEND] Calling Suno extend API', { 
      payload: sunoPayload,
      useCustomParams,
      model: extractedModel
    });

    const sunoResponse = await fetch('https://api.sunoapi.org/api/v1/generate/extend', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${SUNO_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(sunoPayload)
    });

    const sunoData = await sunoResponse.json();

    if (!sunoResponse.ok) {
      logger.error('‚ùå [EXTEND] Suno API error', { 
        status: sunoResponse.status, 
        data: sunoData 
      });
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ç—Ä–µ–∫–∞ –Ω–∞ failed
      await supabaseAdmin
        .from('tracks')
        .update({ 
          status: 'failed', 
          error_message: `Suno API error: ${sunoData.msg || sunoResponse.statusText}` 
        })
        .eq('id', newTrack.id);

      return new Response(
        JSON.stringify({ 
          error: 'Failed to extend track', 
          details: sunoData 
        }),
        { status: 500, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const taskId = sunoData.data?.taskId || sunoData.taskId;
    
    if (!taskId) {
      logger.error('‚ùå [EXTEND] No taskId in Suno response', { sunoData });
      throw new Error('No taskId received from Suno');
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç—Ä–µ–∫ —Å taskId
    await supabaseAdmin
      .from('tracks')
      .update({ 
        metadata: { 
          ...newTrack.metadata, 
          suno_task_id: taskId,
          suno_response: sunoData 
        } 
      })
      .eq('id', newTrack.id);

    logger.info('‚úÖ [EXTEND] Track extension started', { 
      newTrackId: newTrack.id, 
      taskId 
    });

    return new Response(
      JSON.stringify({ 
        success: true, 
        trackId: newTrack.id, 
        taskId,
        message: 'Track extension started' 
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } 
      }
    );

  } catch (error) {
    logger.error('‚ùå [EXTEND] Unexpected error', { error });
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Unknown error' 
      }),
      { status: 500, headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
